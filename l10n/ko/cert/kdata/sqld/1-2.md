
# 1과목 2장 (Subject 1 - Chapter 2)

* **1과목: 데이터 모델링의 이해**
  * **2장: 데이터 모델과 성능**
    * 1절: 정규화와 성능
    * 2절: 반정규화와 성능
    * 3절: 대용량 데이터에 따른 성능
    * 4절: DB 구조와 성능
    * 5절: 분산DB 데이터에 따른 성능

## 성능 데이터 모델링 개요

데이터베이스 성능 향상을 목적으로 설계 단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것.

성능을 분석/설계 단계부터 하지 않으면 시간이 지날수록 성능개선의 비용이 증가하게 된다.

성능 데이터 모델링 고려사항:

* 데이터 모델링 때 정규화를 정확하게 수행
* 데이터베이스 용량 산정을 수행
* DB에 발생하는 트랜잭션 유형 파악
* 용량과 트랜잭션 유형에 따라 반정규화 수행
* 이력 모델, PK/FK, 슈퍼타입/서브타입 등을 조정
* 성능 관점에서 데이터 모델을 검증

## 정규화와 성능

정규화: 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것.

일반적으로 정규화를 수행해야 데이터처리의 성능이 향상되며 데이터의 조회처리 트랜잭션 시에 성능저하가 나타날 수 있음.

함수적 종속성: 데이터들이 어떤 기준값에 의해 종속되는 현상으로 이에 근거하여 정규화가 이루어져야 함.

* 기준값: 결정자(Determinant)
* 종속값: 종속자(Dependent)

## 정규화 종류

* 1차 정규화
  * 속성이 원자값을 갖도록 함. 기본키 보유.
  * 같은 성격과 내용의 속성이 중복될 때 수행
  * 중복값은 제거
  * 새로운 테이블 추가 (PK 추가)
  * 기존 테이블과 1:M 관계 형성
* 2차 정규화
  * 기본키가 2개 이상의 속성일 때 부분 함수 종속성 제거.
  * PK가 2개 이상일 때 종속되는 관계가 있다면 분리
  * 함수적 종속성(FD): 데이터들이 어떠한 기준에 의해서 종속되는 것
    * 완전 함수 종속성: 기본키에 대해 그 속성이 완전히 종속되는 것
    * 부분 함수 종속성: 기본키 전체가 아니라 일부에 대해 종속될 때
* 3차 정규화
  * 기본키에 의존하지 않고 일반 칼럼에 의존하는 칼럼이 있다면 이를 제거

## 반정규화와 성능

정규화된 엔터티, 속성, 관계에 대해 시스템의 성능 향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법

* 데이터 조회 시 디스크 I/O량이 너무 많을 때
* 경로가 너무 멀어 조인으로 인한 성능저하가 너무 클 때

정규화를 다 수행한 후에, 일부 사항을 다시 중복된 값으로 돌려놓으나 데이터 무결성이 깨질 가능성이 큼.

## 반정규화 절차

* 반정규화 대상조사
* 다른 방법 유도 검토
* 반정규화 적용

## 반정규화 기법

* 테이블 반정규화
  * 테이블병합
    * 1:1 관계 테이블병합
    * 1:M 관계 테이블병합
    * 슈퍼/서브타입 테이블병합
  * 테이블분할
    * 수직분할
    * 수평분할
  * 테이블추가
    * 중복테이블 추가
    * 통계테이블 추가
    * 이력테이블 추가
    * 부분테이블 추가
* 칼럼 반정규화
  * 중복칼럼 추가
  * 파생칼럼 추가
  * 이력테이블 칼럼 추가
  * PK에 의한 칼럼 추가
  * 응용시스템 오작동을 위한 칼럼 추가
* 관계 반정규화
  * 중복관계 추가

## 칼럼에 따른 성능 저하 유형

* 로우 체이닝(Row Chaining)
  * 로우 길이가 너무 길어 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
* 로우 마이그레이션(Row Migration)
  * 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

트랜잭션을 분석하여 적절하게 1:1 관계로 분리함으로써 성능향상이 가능하게끔 해야 한다.

## 파티셔닝 유형

파티셔닝(Partitioning): PK에 의한 데이터 분할 방법

* Range Partition
  * 대상 테이블이 날짜 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리되는 경우
  * (ex: 요금 테이블 -> 요금_0401, 요금_0402, ...)
* Hash Partition
  * 지정된 해시 조건에 따라 해싱 알고리즘이 적용되어 테이블을 분리
* List Partition
  * 지점, 사업소, 사업장, 핵심적인 코드값 등으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블이라면 값 각각에 의해 파티셔닝
  * (ex: 고객 테이블 -> 고객_서울, 고객_경기, ...)

## 테이블에 대한 수평/수직분할 절차

* 데이터 모델링 완성
* 데이터베이스 용량산정
* 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴 분석
* 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블 분리를 검토

## 슈퍼타입/서브타입

슈퍼/서브 타입 모델: 업무를 구성하는 데이터의 특징을 공통과 타이점을 고려하여 효과적으로 표현

* 슈퍼타입: 공통적인 부분
* 서브타입: 슈퍼타입으로부터 상속받아, 다른 엔터티와 차이가 있는 속성
* 논리적 데이터 모델에서 사용
* 분석단계에서 사용

## 슈퍼/서브타입 변환기술

* One to One Type
  * 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
* Plus Type
  * 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
* Single Type, All in On
  * 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성

## 인덱스 특성을 고려한 PK/FK DB 성능 향상

* 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 효율성이 좋음
* 앞쪽에 위치한 속성값이 가급적 = 아니면 최소한 범위 BETWEEN < > 가 들어와야 함
  * = 조건이 가장 앞으로, BETWEEN이 그 다음에 오도록 하는 것이 인덱스 범위를 좁힘
* PK 순서를 조정하지 않은 경우의 오류 및 성능 저하 사레에 대해 제시
* 데이터모델에서는 관계를 연결하고 데이터베이스에 FK 제약조건 생성을 생략하는 경우에도 데이터의 조인관계가 필요하기 때문에 FK에 대한 인덱스 생성이 필요

## 분산 DB

* 여러 곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있게 한 DB
* 논리적으로 동일한 시스템에 속하지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있음

분산 DB와 대치되는 개념은 GSI(Global Single Instance)로, 한 개의 인스턴스에서 통합된 DB 구조를 가지고 있음.

## 분산 DB가 되기 위한 6가지 투명성

투명성: 사용자 또는 프로그램의 입장에서, 세부사항을 본인이 직접 알고 있지 않아도 예측 가능한 방식으로 기능을 이용할 수 있음을 의미.

* 위치 투명성
* 중복 투명성
* 병행 투명성
* 분할 투명성
* 장애 투명성
* 지역사상 투명성

## 분산 DB 장단점

* 장점
  * 지역 자치성, 점증적 시스템 용량 확장
  * 신뢰성 및 가용성
  * 효용성 및 유통성
* 단점
  * 소프트웨어 개발 비용
  * 오류의 잠재성 증가
  * 처리 비용 증가

## 분산 DB 적용 기법

* 테이블 위치 분산
* 테이블 분할 분산
* 테이블 복제 분산
* 테이블 요약 분산

## 분산 DB를 적용하기 좋은 경우

* 성능이 중요한 사이트
* 실시간 동기화가 요구되지 않는 경우
* 거의 실시간(Near Real Time)의 업무적인 특징을 가지고 있는 경우
* 특정 서버에 부하가 집중되는 경우
* 백업 사이트(Disaster Recovery Site)를 구성하는 경우
